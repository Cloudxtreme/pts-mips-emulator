#!/usr/bin/env perl

# this file is licensed under the General Public License (GPL) version 3

sub STRACE (){ 0 }
sub PRCPU  (){ 0 }
sub PRIPS  (){ 0 }

use strict;
use warnings;
# Most of $mem[$i] is undef by design, a 0 value is assumed.
no warnings qw(uninitialized);
#use features qw(...);  # None needed.
no utf8;

use Time::HiRes;
use POSIX ();
use Cwd ();
use Fcntl ();

my $use_int32;
BEGIN {
   require integer;
   # Detection works with `use integer' and `no integer'.
   if (((2 ** 31) ** 2 | 0) / 2 ** 31 >= 2 ** 30) {
      if ($ENV{FORCE_INT32}) {
        integer->unimport();  $use_int32 = 1;  # Works.
      } else {
        integer->import();  $use_int32 = 0;  # Works.
      }
   } elsif (((2 ** 15) ** 2 | 0) / 2 ** 15 >= 2 ** 14) {
      if ($ENV{FORCE_INT32}) {
        integer->unimport();  $use_int32 = 1;  # Doesn't work yet.
      } else {
        die "Perl with 32-bit integers not supported yet";
      }
   } else {
      die "Perl with at least 32-bit integers needed";
   }
}
# !! `no integer' 32-bit Perl weirdness on i386:
#    (4294967296 & 4294967295) == 4294967295, should be 0
#    (42 << 32) == 42, should be 42 * 4294967296
#    (5 << 31) == 2147483648, should be 5 * 2147483648
#    good: (1 << 31 >> 31) == 1
# !! `use integer' 64-bit Perl weirdness:
#    (1 << 63 >> 63) == -1

#############################################################################
# system state


sub ADDR_SHIFT(){         16 }
sub ADDR_MASK (){     0x3fff }

sub STACK     (){ 0xf00f0000 }
sub MINBRK    (){ 0x10000000 }

sub M32       (){ 0xffffffff }
sub B31       (){ 0x80000000 }
sub M16       (){     0xffff }
sub B15       (){     0x8000 }
sub M8        (){       0xff }
sub B7        (){       0x80 }

# !! TODO(pts): Make it faster for !$use_int32.
# $_[0] can be any number between -2**53 and 2**53. The return value is
# between 0 and 4294967295.
sub mask32($) {
   return $use_int32 ? $_[0] % 4294967296 : $_[0] & M32;
}
# !! TODO(pts): Make it faster for !$use_int32.
# !! TODO(pts): Make it faster for $use_int32 (and with mask, then shift).
# Shift left.
sub shl($$) {
   die "bad shift amount\n" if $_[1] < 0 or $_[1] > 32;
   return $use_int32 ? $_[0] * (2 ** $_[1]) % 4294967296 : ($_[0] << $_[1]) & M32;
}
# !! double check ~ (bitwise not)

my @mem; # [16bits][14bits] = 32bits

sub xxd($) {
   open my $fh, "| xxd" or die;
   print $fh $_[0];
}

sub memset($$) {
   die "memset too early" if $_[0] < 0;
   die "memset too long" if $_[0] + length($_[1]) > 4294967296;

   for (0 .. (length $_[1]) - 1) {
      my $i = $_[0] + $_;
      my $c = unpack "C", substr $_[1], $_, 1;

      my $s = (~$i & 3) << 3;
      $i = \vec($mem[$i >> ADDR_SHIFT], ($i >> 2) & ADDR_MASK, 32);
      $$i = $$i & ~(0xff << $s) | ($c << $s);
   }
}

sub memget($$) {
   die "memget too early" if $_[0] < 0 or $_[1] < 0;
   die "memget too long" if $_[0] + $_[1] > 4294967296;

   my $r;

   for my $i ($_[0] .. $_[0] + $_[1] - 1) {
      my $s = (~$i & 3) << 3;
      $r .= pack "C", ((vec($mem[$i >> ADDR_SHIFT], ($i >> 2) & ADDR_MASK, 32) >> $s) & 0xff);
   }

   $r
}

sub memstr($) {
   die "memstr too early" if $_[0] < 0;
   die "memset too long" if $_[0] > 4294967295;
   my $r;

   for (my $i = $_[0]; ; ++$i) {
      die "memset too long" if $i > 4294967295;
      my $s = (~$i & 3) << 3;
      $r .= pack "C", ((vec($mem[$i >> ADDR_SHIFT], ($i >> 2) & ADDR_MASK, 32) >> $s) & 0xff)
                      || last;
   }

   $r
}

sub mem_reset() {
   @mem = ();
}

############################################

my ($pc, $hi, $lo, $delay); # cpu state

my (
   $r0 , $r1 , $r2 , $r3 , $r4 , $r5 , $r6 , $r7 ,
   $r8 , $r9 , $r10, $r11, $r12, $r13, $r14, $r15,
   $r16, $r17, $r18, $r19, $r20, $r21, $r22, $r23,
   $r24, $r25, $r26, $r27, $r28, $r29, $r30, $r31,
);

my $insn;

my %insn2src; # insn to perl source
my %insn2sub; # insn to compiled perl sub
my %sub2insn; # sub+0 to insn code

{
   our ($hint_bits, $warning_bits, %hint_hash);

   BEGIN {
     ($hint_bits, $warning_bits, %hint_hash) = ($^H, ${^WARNING_BITS}, %^H);
   }

   sub deparse {
      require B::Deparse;
      my $deparser = new B::Deparse;
      $deparser->ambient_pragmas (
         hint_bits    => $hint_bits,
         warning_bits => $warning_bits,
         '$['         => $[+0,
         integer      => 1,
         '%^H'        => \%hint_hash,
      );
      $deparser->coderef2text ($_[0])
   }
}

sub cpu_pr {
   printf " 0 %8x=zr %8x=at %8x=v0 %8x=v1 %8x=a0 %8x=a1 %8x=a2 %8x=a3\n", $r0 , $r1 , $r2 , $r3 , $r4 , $r5 , $r6 , $r7;
   printf " 8 %8x=t0 %8x=t1 %8x=t2 %8x=t3 %8x=t4 %8x=t5 %8x=t6 %8x=t7\n", $r8 , $r9 , $r10, $r11, $r12, $r13, $r14, $r15;
   printf "16 %8x=s0 %8x=s1 %8x=s2 %8x=s3 %8x=s4 %8x=s4 %8x=s6 %8x=s6\n", $r16, $r17, $r18, $r19, $r20, $r21, $r22, $r23;
   printf "24 %8x=t8 %8x=t9 %8x=k0 %8x=k1 %8x=gp %8x=sp %8x=fp %8x=ra\n", $r24, $r25, $r26, $r27, $r28, $r29, $r30, $r31;

   my $code = $sub2insn{$insn+0};
   my $src  = $insn2src{$code} ||= deparse $insn;
   $src =~ s/\s+/ /g;
   printf "%x: %08x (%s)\n", $pc * 4, $code, $src;
}

############################################
# syscalls

# mips abi
sub ENOENT (){  2 }
sub EBADF  (){  9 }
sub ENOMEM (){ 12 }
sub ENOTTY (){ 25 }
sub ERANGE (){ 34 }
sub EAGAIN (){ 35 }
sub ENOSYS (){ 89 }

sub O_ACCMODE   (){    0003 }
sub O_RDONLY    (){      00 }
sub O_WRONLY    (){      01 }
sub O_RDWR      (){      02 }
sub O_APPEND    (){  0x0008 }
sub O_SYNC      (){  0x0010 }
sub O_NONBLOCK  (){  0x0080 }
sub O_CREAT     (){  0x0100 } # not fcntl
sub O_TRUNC     (){  0x0200 } # not fcntl
sub O_EXCL      (){  0x0400 } # not fcntl
sub O_NOCTTY    (){  0x0800 } # not fcntl
sub O_ASYNC     (){  0x1000 }
sub O_NOFOLLOW  (){ 0x20000 }
sub O_DIRECT    (){  0x8000 }
sub O_DIRECTORY (){ 0x10000 }
sub O_NOATIME   (){ 0x40000 }

sub errno2mips($) {
   # TODO(pts): Implement this correctly, `use Errno' etc.
   $_[0]*1
}

sub mips2omode($) {
   my $mmode = shift;

   my $omode = 0;

   $omode |= Fcntl::O_RDONLY if ($mmode & O_ACCMODE) == O_RDONLY;
   $omode |= Fcntl::O_WRONLY if ($mmode & O_ACCMODE) == O_WRONLY;
   $omode |= Fcntl::O_RDWR   if ($mmode & O_ACCMODE) == O_RDWR;

   for my $mode (qw(
      APPEND SYNC NONBLOCK CREAT TRUNC EXCL NOCTTY
      ASYNC NOFOLLOW DIRECT DIRECTORY NOATIME
   )) {
      eval "\$omode |= Fcntl::O_$mode if \$mmode & O_$mode";
   }

   $omode
}

my $enosys = sub {
   warn "unimplemented syscall $r2\n";
   die;
};

my @syscall = ($enosys) x 7000;

############################################

my @fh;
my @dh; # directory-handles, HACK
my $strace;

for my $fd (3..9) {
   open my $fh, "+<&=", $fd
      or next;

   $fh[$fd] = $fh;
}
for my $fd (0..2) {
   open my $fh, "+<&", $fd
      or next;

   $fh[$fd] = $fh;
}

sub fd_valid($) {
   !($_[0] & ~65535)
   && $fh[$_[0]]
}

############################################

sub strace($;@) {
   $strace = $#_
      ? sprintf $_[0], @_[1..$#_]
      : shift;
}

sub newfd($) {
   my $fd;
   ++$fd while $fh[$fd];
   $fh[$fd] = $_[0];
   $fd
}

sub reify_fds {
   my $top = 512;

   for my $fd (0..$#fh) {
      next unless $fh[$fd];

      POSIX::dup2 fileno $fh[$fd], $top + $fd;
      close $fh[$fd];
   }

   for my $fd (0..$#fh) {
      next unless $fh[$fd];

      POSIX::dup2 $top + $fd, $fd;
      POSIX::close $top + $fd;

      open my $fh, "+<&=", $fd
        or die;

     $fh[$fd] = $fh;
   }
}

############################################

sub newstat {
   my $buf = shift;

   if (@_) {
      my $stat = pack "N x12 NNNNN x8 N x4 NN NN NN N N x56",
         $_[ 0], # dev
         $_[ 1], # ino
         $_[ 2], # mode
         $_[ 3], # nlink
         $_[ 4], # uid
         $_[ 5], # gid
         $_[ 6], # rdev
         $_[ 7], # size
         $_[ 8], 0, # atime
         $_[ 9], 0, # mtime
         $_[10], 0, # ctime
         $_[11], # blksize
         $_[12]; # blocks

      memset $buf, $stat;

      return 0;
   }

   -errno2mips($! + 0)
};

sub stat64 {
   my $buf = shift;

   if (@_) {
      my $stat = pack "N x12 NN NNNNN x12 NN NN NN NN N x4 NN",
         $_[ 0], # dev
         $use_int32 ? int($_[1] / 4294967296) : $_[ 1] >> 32, $_[1], # ino
         $_[ 2], # mode
         $_[ 3], # nlink
         $_[ 4], # uid
         $_[ 5], # gid
         $_[ 6], # rdev
         $use_int32 ? int($_[7] / 4294967296) : $_[ 7] >> 32, $_[7], # size
         $_[ 8], 0, # atime
         $_[ 9], 0, # mtime
         $_[10], 0, # ctime
         $_[11],    # blksize
         $use_int32 ? int($_[12] / 4294967296) : $_[12] >> 32, $_[12]; # blocks

      memset $buf, $stat;

      return 0;
   }

   -errno2mips($! + 0)
};

sub sys_fcntl {
   my ($fd, $cmd, $arg) = @_;
   strace "fcntl (%d, %x, %x)", $fd, $cmd, $arg;
   fd_valid $fd or return -(EBADF);

   if ($cmd == 0) { # F_DUPFD
      ++$arg while $fh[$arg];
      open my $fh, "+<&", fileno $fh[$fd]
         or return -errno2mips($! + 0);
      $fh[$arg] = $fh;
      return $arg;
   } elsif ($cmd == 1) { # F_GETFD
      return fcntl $fh[$fd], Fcntl::F_GETFD, 0;
   } elsif ($cmd == 2) { # F_SETFD
      return +(fcntl $fh[$fd], Fcntl::F_SETFD, $arg+0)
         ? 0 : -errno2mips($! + 0);
   } elsif ($cmd == 3) { # F_GETFL
      return O_RDWR; # HACK
   } else {
      # 4 F_SETFL
      warn sprintf"unknown fcntl %d,%x,%x\n", $fd, $cmd, $arg;
   }

   -(ENOSYS)
};

############################################

$syscall[4001] = sub { # exit
   strace "exit ($_[0])";
   exit $_[0];
};
$syscall[4002] = sub { # fork
   strace "fork";

   my $pid = fork;
   return -errno2mips($! + 0) unless defined $pid;
   $pid
};
$syscall[4003] = sub { # read
   my ($fd, $rbuf, $count) = @_;
   strace "read (%d, %x, %d)", $fd, $rbuf, $count;

   $count = sysread $fh[$fd], my($buf), $count;

   memset $rbuf, $buf;

   defined $count ? $count : -errno2mips($! + 0)
};

$syscall[4004] = sub { # write
   my ($fd, $buf, $count) = @_;
   strace "write (%d, %x, %d)", $fd, $buf, $count;

   $count = syswrite $fh[$fd], memget $buf, $count;
   defined $count ? $count : -errno2mips($! + 0)
};
$syscall[4005] = sub { # open
   my ($path, $flags, $mode) = @_;
   $path = memstr $path;
   strace "open (%s, %x, %o)", $path, $flags, $mode;

   if (opendir my $dh, $path) {#d#
      open my $fh, "</dev/null"or die;
      my $fd = newfd $fh;
      $dh[$fd] = $dh;
      return $fd;
   }

   sysopen my $fh, $path, mips2omode $flags, $mode
      or return -errno2mips($! + 0);

   newfd $fh
};
$syscall[4006] = sub { # close
   my ($fd) = @_;
   strace "close ($fd)";
   fd_valid $fd or return -(EBADF);

   undef $dh[$fd];#d#
   (close delete $fh[$fd])
      ? 0 : -errno2mips($! + 0)
};

$syscall[4010] = sub { # unlink
   my ($path) = @_;
   $path = memstr $path;
   strace "unlink (%s)", $path;

   (defined unlink $path)
      ? 0 : -errno2mips($! + 0)
};
$syscall[4011] = sub { # execve
   my ($path, $argv, $envv) = @_;
   $path = memstr $path;

   for my $vec ($argv, $envv) {
      my $addr = $vec;
      $vec = [];
      while () {
         my $ptr = unpack "N", memget $addr, 4
            or last;
         push @$vec, memstr $ptr;
         $addr += 4;
      }
   }

   local %ENV;
   /([^=]*)=(.*)/s, $ENV{$1} = $2
      for @$envv;

   ($path, $argv->[0]) = ($argv->[0], $path);

   reify_fds;
     
   die "unexpected success from exec" if exec {$path} @$argv;

   # not normally printed...
   strace "execve (%s, [%s], [%s])", $path, (join "|", @$argv), (join "|", @$envv);

   -errno2mips($! + 0)
};
$syscall[4012] = sub { # chdir
   my $path = memstr $_[0];
   strace "chdir (%s)", $path;

   (chdir $path) ? 0 : -errno2mips($! + 0)
};
$syscall[4013] = sub { # time
   my ($rbuf) = @_;
   strace "time (%x)", $rbuf;

   my $time = time;

   memset $rbuf, pack "N", $time;
   $time
};

$syscall[4020] = sub { strace "getpid ()"; $$ };

$syscall[4024] = sub { strace "getuid ()"; $< };

$syscall[4033] = sub { # access
   my ($path, $mode) = @_;
   $path = memstr $path;
   strace "acess (%s, %o)", $path, $mode;

   0

};

$syscall[4037] = sub { # kill
   strace "kill ($_[0], $_[1])";
   
   (kill $_[1], $_[0]) # todo signal numbers?
      ? 0 : -errno2mips($! + 0)
};

$syscall[4041] = sub { # dup
   my ($fd) = @_;
   strace "dup ($fd)";
   fd_valid $fd or return -(EBADF);

   open my $fh, "+<&", fileno $fh[$fd]
      or return -errno2mips($! + 0);

   newfd $fh
};
$syscall[4042] = sub { # sysm_pipe
   strace "sysm_pipe ()";

   pipe my $r, my $w
      or return -errno2mips($! + 0);

   $r = newfd $r;
   $w = newfd $w;

   strace "sysm_pipe ($r, $w)";

   $r3 = $w;
         $r
};

$syscall[4045] = sub { # brk
   strace "brk (%x)", $_[0];
   my $brk = $_[0];
   $brk = MINBRK if $brk < MINBRK;
   $brk
}; # brk

$syscall[4047] = sub { strace "getgid ()" ; $( };

$syscall[4049] = sub { strace "geteuid ()"; $> };
$syscall[4050] = sub { strace "getegid ()"; $) };

$syscall[4054] = sub { # ioctl
   my ($fd, $req, $arg) = @_;
   strace "ioctl (%d, %x, %x)", $fd, $req, $arg;
   fd_valid $fd or return -(EBADF);

   if ($req == 0x540d) { # TCGETS
      if (-t $fh[$fd]) {
         memset $arg, pack "NNNN C C23";
         return 0;
      }
   } elsif ($req == 0x540f) { # TCSETW
      return 0;
   } elsif ($req == 0x40047477) { # TIOCGPGRP # irix???
      memset $arg, pack "N", getpgrp; # hacky, but does...
      return 0;
   } elsif ($req == 0x80047476) { # TIOCSPGRP # irix???
      return 0; # whatever you say...
   } elsif ($req == 0x40087468) { # TIOCGWINSZ
      return -(ENOSYS);
   } else {
      warn sprintf"unknown ioctl %d,%x,%x\n", $fd, $req, $arg;
   }

   -(ENOTTY)
};
$syscall[4055] = \&sys_fcntl; # fcntl

$syscall[4057] = sub { # getpgid
   strace "getpgid ($_[0])";

   $_[0] == $$
      ? getpgrp : $$ # hacky, but it's a bsd'ism
};

$syscall[4060] = sub { strace "umask (%o)", $_[0]; umask $_[0] };

$syscall[4063] = sub { # dup2
   my ($fd1, $fd2) = @_;
   strace "dup2 ($fd1, $fd2)";
   fd_valid $fd1 or return -(EBADF);

   open my $fh, "+<&", fileno $fh[$fd1]
      or return -errno2mips($! + 0);

   $dh[$fd2] = $dh[$fd1];
   $fh[$fd2] = $fh;
   $fd2
};

$syscall[4064] = sub { strace "getppid ()"; getppid };
$syscall[4065] = sub { strace "getpgrp ()"; getpgrp };

$syscall[4075] = sub { # setrlimit
   my ($resource, $rlim) = @_;
   strace "setrlimit (%d, %x)", $resource, $rlim;

   0
};
$syscall[4076] = sub { # getrlimit
   my ($resource, $rlim) = @_;
   strace "getrlimit (%d, %x)", $resource, $rlim;

   -(ENOSYS)
};

$syscall[4078] = sub { # gettimeofday
   my ($tv, $tz) = @_;
   strace "gettimeofday (%x, %x)", $tv, $tz;

   my ($s, $m) = Time::HiRes::gettimeofday;
   memset $tv, pack "NN", $s, $m if $tv;
   memset $tz, pack "NN", 0, 0 if $tz; # minuteswest, dsttime

   0
};

#$syscall[4080] = sub { # getgroups

$syscall[4090] = sub {
   # SYSCALL_DEFINE6(mips_mmap, unsigned long, addr, unsigned long, len,
   #         unsigned long, prot, unsigned long, flags, unsigned long,
   #         fd, off_t, offset)

   strace "mips_mmap (%x, %d, %x, %x, %d, %d)", @_;
   -(ENOSYS)
};

$syscall[4097] = sub { # setpriority
   # ...
   -(ENOSYS)
};

$syscall[4099] = sub { # statfs
   my ($path, $buf) = @_;
   $path = memstr $path;
   strace "statfs (%s, %x)", $path, $buf;

   -(ENOSYS)
};
$syscall[4100] = sub { # fstatfs
   my ($fd, $buf) = @_;
   strace "fstatfs (%d, %x)", $fd, $buf;

   -(ENOSYS)
};

$syscall[4106] = sub { # newstat
   my ($path, $buf) = @_;
   $path = memstr $path;
   strace "newstat (%s, %x)", $path, $buf;

   newstat $buf, stat $path
};
$syscall[4107] = sub { # newlstat
   my ($path, $buf) = @_;
   $path = memstr $path;
   strace "newlstat (%s, %x)", $path, $buf;

   newstat $buf, lstat $path
};
$syscall[4108] = sub { # newfstat
   my ($fd, $buf) = @_;
   strace "newfstat (%d, %x)", $fd, $buf;

   newstat $buf, stat $fh[$fd]
};

$syscall[4114] = sub { # wait4
   my ($pid, $statusbuf, $options, $rusage) = @_;
   $pid = unpack "l", pack "L", $pid;
   strace "wait4 (%d, %x, %x, %x)", $pid, $statusbuf, $options, $rusage;

   memset $rusage, "\x00" x 72
      if $rusage;
   
   $pid = waitpid $pid, $options;

   memset $statusbuf, pack "N", $? if $statusbuf;

   $pid >= 0 ? $pid : -errno2mips($! + 0)
};

$syscall[4122] = sub { # newuname
   my ($buf) = @_;
   strace "newuname (%x)", $buf;

   memset $buf, pack "a65 a65 a65 a65 a65 a65", #d#
      "sysname",
      "nodename",
      "release",
      "version",
      "machine",
      "domainname";

   0
};

$syscall[4140] = sub { # llseek
   my ($fd, $high, $low, $result, $whence) = @_;
   strace "llseek (%d, %x, %08x, %x, %d)", $fd, $high, $low, $result, $whence;
   # Some systems don't support high-absolute-value 64-bit seek offsets for
   # sysseek.
   #
   # TODO(pts): $use_int32: At least we should check the return value.
   my $ofs = $low +
       ($use_int32 ? 4294967296 * ($high - ($high & 2147483648) * 2) :
       $high << 32);

   my $res = sysseek $fh[$fd], $ofs, $whence;

   memset $result, pack "NN",
       ($use_int32 ? int($res / 4294967296) : $res >> 32), $res;

   defined $res
      ? 0 : -errno2mips($! + 0)
};

$syscall[4194] = sub { # sigaction
   my ($signum, $act, $oldact) = @_;
   strace "sigaction (%d, %x, %x)", $signum, $act, $oldact;
   -(ENOSYS)
};
$syscall[4195] = sub { # sigprocmask
   my ($how, $set, $oldset) = @_;
   strace "sigprocmask ($how, $set, $oldset)";

   -(ENOSYS)
};

$syscall[4203] = sub { # getcwd
   my $cwd = Cwd::getcwd;
   strace "getcwd (%x, %d)", $_[0], $_[1];

   if ((length $cwd) < $_[1]) {
      memset $_[0], "$cwd\x00";
      return 1 + length $cwd;
   } else {
      return -(ERANGE);
   }
};

$syscall[4213] = sub { # stat64
   my ($path, $buf) = @_;
   $path = memstr $path;
   strace "stat64 (%s, %x)", $path, $buf;

   stat64 $buf, stat $path
};
$syscall[4214] = sub { # lstat64
   my ($path, $buf) = @_;
   $path = memstr $path;
   strace "lstat64 (%s, %x)", $path, $buf;

   stat64 $buf, lstat $path
};
$syscall[4215] = sub { # fstat64
   my ($fd, $buf) = @_;
   strace "fstat64 (%d, %x)", $fd, $buf;

   stat64 $buf, stat $fh[$fd]
};

$syscall[4219] = sub { # getdents64
   my ($fd, $dirp, $count) = @_;
   strace "getdents64 (%d, %x, %d)", $fd, $dirp, $count;

   my $name = readdir $dh[$fd];

   return 0 unless defined $name;

   my $ino = -1;
   my $type = 0;

   my $entry = pack "NN NN n C Z*",
      ($use_int32 ? int($ino / 4294967296) : $ino >> 32), $ino,
      0, 0, # offset
      (length $name) + 20,
      $type,
      $name;

   memset $dirp, $entry;
   length $entry
};
$syscall[4220] = \&sys_fcntl; # fcntl64

$syscall[4283] = sub { # set_thread_area
   my ($udesc) = @_;

   strace "set_thread_area (%x)", $udesc;

   -(ENOSYS)
};

$syscall[4300] = sub { # faccessat
   my ($dirfd, $path, $mode, $flags) = @_;

   strace "faccessat (%d, %s, %o, %x)", $dirfd, $path, $mode, $flags;

   0 # #d# grant any access
};

sub sys {
   my @args =  map $_*1,  # TODO(pts): Any faster than *1?
      $r4, $r5, $r6, $r7, # first four args in regs
      # extra arguments on stack
      vec($mem[($r29 + 16) >> ADDR_SHIFT], (($r29 + 16) >> 2) & ADDR_MASK, 32),
      vec($mem[($r29 + 20) >> ADDR_SHIFT], (($r29 + 20) >> 2) & ADDR_MASK, 32),
      vec($mem[($r29 + 24) >> ADDR_SHIFT], (($r29 + 24) >> 2) & ADDR_MASK, 32),
      vec($mem[($r29 + 28) >> ADDR_SHIFT], (($r29 + 28) >> 2) & ADDR_MASK, 32),
   ;

   #print STDERR "!! SYSCALL $r2 (@args)\n";
   $strace = "$r2 (@args)";
   my $retval = $syscall[$r2](@args);
   print STDERR "$$ SYS_$strace = $retval\n" if STRACE;

   if ($retval > -4096 && $retval < 0) {
      $r2 = -$retval;
      $r7 = 1;
   } else {
      $r2 = $retval;
      $r7 = 0;
   }
}

#############################################################################
# mips i big endian cpu emulator

############################################
# specials (opcode 0)

my ($s, $t, $i); # "global" for speed

my @special = ('die "special ", $insn & 63, " not supported"') x 64;

$special[ 0] = "RD = shl(RT, SA)"; # sll

$special[ 2] = 'RD =  RT                       >> SA              '; # srl

$special[ 3] = 'die "fix.for.\$use_int32.sra" if $use_int32 and RT < 0; RD = mask32((RT - ((RT & B31) * 2)) >> SA       )'; # sra
$special[ 4] = 'RD =  shl(RT, (RS & 31))'; # sllv

$special[ 6] = 'RD =   RT                     >> (RS & 31)       '; # srlv
$special[ 7] = 'die "fix.for.\$use_int32.srav" if $use_int32 and RT < 0; RD = mask32((RT - ((RT & B31) * 2)) >> (RS & 31))'; # srav
$special[ 8] = '               $pc = RS >> 2'; # jr
$special[ 9] = 'RD = $pc << 2; $pc = RS >> 2'; # jalr

$special[12] = "sys";
$special[13] = "die sprintf \"BREAK (%08x)\\\n\", $insn"; # break

$special[16] = 'RD = $hi'; # mfhi
$special[17] = '$hi = RS'; # mthi
$special[18] = 'RD = $lo'; # mflo
$special[19] = '$lo = RS'; # mtlo

if ($use_int32) {
   # It works with both 32-bit and 64-bit Perl, but only with `no integer'.
   #
   # It is doing https://en.wikipedia.org/wiki/IEEE_754 64-bit float
   # (double) arithmetics with 53-bit significand, thus it's OK to multiply
   # a 16-bit and a 32-bit unsigned integer.
   $special[24] =  '# mult
      if (RS <= 2147483647 and RT <= 2147483648 and ($s = RS * RT) <= 9007199254740991) {  # Shortcut.
         $lo = $s % 4294967296;
         $hi = ($s - $lo) / 4294967296;
      } else {  # TODO(pts): Can we do it any shorter?
         $s = RS;
         $t = RT;
         my $sign = 1;
         ($s, $sign) = (4294967296 - $s, -$sign) if $s > 2147483647;
         ($t, $sign) = (4294967296 - $t, -$sign) if $t > 2147483647;
         $lo = $s % 65536;
         $hi = ($s - $lo) / 65536 * $t;
         $lo *= $t;
         $t = $hi % 65536;
         $lo += $t * 65536;
         $hi = ($hi - $t) / 65536;
         $t = $lo % 4294967296;
         $hi += ($lo - $t) / 4294967296;
         $lo = $t;
         if ($sign < 0) {
            if ($lo) {
               $lo = 4294967296 - $lo;
               $hi = 4294967295 - $hi;
            } else {
               $hi = 4294967296 - $hi;
            }
         }
      }
      #printf STDERR "CALL mult(0x%08x,0x%08x)=(0x%08x,0x%08x)\n", RS, RT, $lo, $hi;
      ';
   $special[25] = ' # multu
      $s = RS * RT;
      if ($s <= 9007199254740991) {  # Shortcut.
         $lo = $s % 4294967296;
         $hi = ($s - $lo) / 4294967296;
      } else {
         $lo = RS % 65536;
         $hi = (RS - $lo) / 65536 * RT;
         $lo *= RT;
         $t = $hi % 65536;
         $lo += $t * 65536;
         $hi = ($hi - $t) / 65536;
         $t = $lo % 4294967296;
         $hi += ($lo - $t) / 4294967296;
         $lo = $t;
      }
      #printf STDERR "CALL multu(0x%08x,0x%08x)=(0x%08x,0x%08x)\n", RS, RT, $lo, $hi;
      ';
   $special[26] = ' # div
      $s = RS - ((RS & B31) * 2);
      $t = RT - ((RT & B31) * 2)
         or return;
      # Sign of the remainder ($hi) will be the sign of $t with no integer (here).
      # Sign of the remainder ($hi) would be the sign of $s with use integer.
      $hi = $s % $t;
      $hi -= $t if $hi and (($s > 0 and $t < 0) or ($s < 0 and $t > 0));
      $lo = mask32(($s - $hi) / $t);
      $hi = mask32($hi);
      #printf STDERR "CALL div(0x%08x,0x%08x)=(0x%08x,0x%08x)\n", RS, RT, $lo, $hi;
   ';
   $special[27] = ' # divu
      RT or return;
      $hi = RS % RT;
      $lo = (RS - $hi) / RT;
      #printf STDERR "CALL divu(0x%08x,0x%08x)=(0x%08x,0x%08x)\n", RS, RT, $lo, $hi;
   ';
} else {
   $special[24] =  '# mult 64-bit
      $lo = (RS - ((RS & B31) << 1))
          * (RT - ((RT & B31) << 1));
      $hi = ($lo >> 32) & M32;
      $lo &= M32;
      #printf STDERR "CALL mult(0x%08x,0x%08x)=(0x%08x,0x%08x)\n", RS, RT, $lo, $hi;
   ';
   $special[25] = ' # multu 64-bit
      $lo = RS * RT;
      $hi = ($lo >> 32) & M32;
      $lo &= M32;
      #printf STDERR "CALL multu(0x%08x,0x%08x)=(0x%08x,0x%08x)\n", RS, RT, $lo, $hi;
   ';
   $special[26] = ' # div 64-bit
      $s = RS - ((RS & B31) << 1);
      $t = RT - ((RT & B31) << 1)
         or return;

      $lo = ($s / $t) & M32;
      $hi = ($s % $t) & M32;
      #printf STDERR "CALL div(0x%08x,0x%08x)=(0x%08x,0x%08x)\n", RS, RT, $lo, $hi;
   ';
   $special[27] = ' # divu 64-bit
      RT or return;

      $lo = RS / RT;
      $hi = RS % RT;
      #printf STDERR "CALL divu(0x%08x,0x%08x)=(0x%08x,0x%08x)\n", RS, RT, $lo, $hi;
   ';
}

$special[32] = 'die "add instruction unsupported"';
$special[33] = "RD = mask32(RS + RT)"; # addu
$special[34] = 'die "sub instruction unsupported"';
$special[35] = "RD = mask32(RS - RT)"; # subu
#$special[32] = $special[33]; # add # buggy, does not trap #d#
#$special[34] = $special[35]; # sub # buggy, does not trap #d#

$special[36] = "RD =  RS & RT       "; # and
$special[37] = "RD =  RS | RT       "; # or
$special[38] = "RD =  RS ^ RT       "; # xor
$special[39] = "RD = (RS ^ RT) ^ M32"; # nor

$special[42] = "RD = (RS - ((RS & B31) * 2)) < (RT - ((RT & B31) * 2))"; # slt
$special[43] = "RD =  RS                     <  RT                    "; # sltu

############################################
# regimm (opcode 1)

my @regimm = ('die "regimm $insn not supported"') x 32;

# !! What if $pc overflows or underflows here?
$regimm[ 0] = '                    $pc += IMM - 1  if     RS & 0x80000000'; # bltz
$regimm[16] = '($r31 = $pc << 2), ($pc += IMM - 1) if     RS & 0x80000000'; # bltzal
$regimm[ 1] = '                    $pc += IMM - 1  unless RS & 0x80000000'; # bgez
$regimm[17] = '($r31 = $pc << 2), ($pc += IMM - 1) unless RS & 0x80000000'; # bgezal bal

############################################
# others

my @opcode;

$opcode[ 0] = sub { $special[$insn & 63] }; # special
$opcode[ 1] = sub { $regimm[($insn >> 16) & 31] }; # regimm
$opcode[ 2] = sub { '                 $pc = ($pc & 0x3c000000) | (' . $insn . ' & 0x03ffffff)' }; # j
$opcode[ 3] = sub { '$r31 = $pc << 2; $pc = ($pc & 0x3c000000) | (' . $insn . ' & 0x03ffffff)' }; # jal
$opcode[ 4] = sub { '($pc += IMM - 1) if RS == RT' }; # beq beqz b
$opcode[ 5] = sub { '($pc += IMM - 1) if RS != RT' }; # bne bnez
$opcode[ 6] = sub { '($pc += IMM - 1) if !RS || RS >= 0x80000000' }; # blez
$opcode[ 7] = sub { '($pc += IMM - 1) if  RS && RS <  0x80000000' }; # bgtz
$opcode[ 8] = sub { die "addi instruction unsupported" }; # addi
$opcode[ 9] = sub { "RT = mask32(RS + IMM)" }; # addiu
$opcode[10] = sub { 'RT = ((RS - ((RS & B31) * 2))) <  IMM       ' }; # slti
$opcode[11] = sub { 'RT =   RS                      < (mask32(IMM))' }; # sltiu
$opcode[12] = sub { 'RT = RS & IMMU' }; # andi
$opcode[13] = sub { 'RT = RS | IMMU' }; # ori
$opcode[14] = sub { 'RT = RS ^ IMMU' }; # xori
$opcode[15] = sub { 'RT = IMMU << 16' }; # lui

$opcode[32] = sub {' # lb
   $i = RS + IMM;
   $s = (~$i & 3) << 3;
   $s = vec($mem[$i >> ADDR_SHIFT], ($i >> 2) & ADDR_MASK, 32) >> $s;
   RT = mask32(($s &  M8) - (($s &  B7) * 2));
'};
$opcode[33] = sub {' # lh
   $i = RS + IMM;
   $s = (~$i & 2) << 3;
   $s = vec($mem[$i >> ADDR_SHIFT], ($i >> 2) & ADDR_MASK, 32) >> $s;
   RT = mask32(($s & M16) - (($s & B15) * 2));
'};
$opcode[34] = sub {' # lwl
   $i = RS + IMM;
   $s = ($i & 3) << 3;
   $i = vec($mem[$i >> ADDR_SHIFT], ($i >> 2) & ADDR_MASK, 32);
   RT = (RT & (M32 >> (32 - $s))) | (shl($i, $s));
'};
$opcode[35] = sub {' # lw
   $i = RS + IMM;
   RT = vec($mem[$i >> ADDR_SHIFT], ($i >> 2) & ADDR_MASK, 32);
'};
$opcode[36] = sub {' # lbu
   $i = RS + IMM;
   $s = (~$i & 3) << 3;
   RT = (vec($mem[$i >> ADDR_SHIFT], ($i >> 2) & ADDR_MASK, 32) >> $s) & M8;
'};
$opcode[37] = sub {' # lhu
   $i = RS + IMM;
   $s = (~$i & 2) << 3;
   RT = (vec($mem[$i >> ADDR_SHIFT], ($i >> 2) & ADDR_MASK, 32) >> $s) & M16;
'};
$opcode[38] = sub {' # lwr
   $i = RS + IMM;
   $s = (($i & 3) + 1) << 3;
   $i = vec($mem[$i >> ADDR_SHIFT], ($i >> 2) & ADDR_MASK, 32);
   die "fix.for.\$use_int32.lwr" if $use_int32 and ($s == 0 or $s == 32);
   RT = shl(RT >> $s, $s) | ($i >> (32 - $s));
'};

$opcode[40] = sub {' # sb
   $i = RS + IMM;
   $s = (~$i & 3) << 3;
   $i = \vec($mem[$i >> ADDR_SHIFT], ($i >> 2) & ADDR_MASK, 32);
   $$i = ($$i & ~(M8  << $s)) | (RT & M8 ) << $s;
'};
$opcode[41] = sub {' # sh
   $i = RS + IMM;
   $s = (~$i & 2) << 3;
   $i = \vec($mem[$i >> ADDR_SHIFT], ($i >> 2) & ADDR_MASK, 32);
   $$i = ($$i & ~(M16 << $s)) | (RT & M16) << $s;
'};
$opcode[42] = sub {' # swl
   $i = RS + IMM;
   $s = ((~$i & 3) + 1) << 3;
   $i = \vec($mem[$i >> ADDR_SHIFT], ($i >> 2) & ADDR_MASK, 32);
   die "fix.for.\$use_int32.swl" if $use_int32 and ($s == 0 or $s == 32);
   $$i = shl($$i >> $s, $s) | (RT >> (32 - $s));
'};
$opcode[43] = sub {' # sw
   $i = RS + IMM;
   vec($mem[$i >> ADDR_SHIFT], ($i >> 2) & ADDR_MASK, 32) = RT;
'};

$opcode[46] = sub {' # swr
   $i = RS + IMM;
   $s = (($i & 3) + 1) << 3;
   $i = \vec($mem[$i >> ADDR_SHIFT], ($i >> 2) & ADDR_MASK, 32);
   die "fix.for.\$use_int32.swr" if $use_int32 and ($s == 0 or $s == 32);
   $$i = $$i & (M32 >> $s) | shl(RT, 32 - $s));
'};

# 0x7c03e83b rdhwr $3, $29 ($29=tls)- emulated by kernel normally, for thread support

my $NOP = sub { };

sub get_insn {
   $insn2sub{$_[0]} ||= do {
      my $old_insn = $insn;#d#

      $insn = $_[0]*1;
      # TODO(pts): When do we fail with this? Can't use an undefined value as a subroutine reference
      my $src = &{ $opcode[$insn >> 26] };

      $src =~ s/\bIMM\b/($insn & M16) - (($insn & B15) << 1)/ge; # 16 bit signed immediate
      $src =~ s/\bIMMU\b/$insn & M16/ge;                         # 16 bit unsigned immediate

      $src =~ s/\bSA\b/($insn >> 6) & 31/ge;                     # shift amount

      $src =~ s/\bRS\b/'$r' . (($insn >> 21) & 31)/ge;           # s register
      $src =~ s/\bRT\b/'$r' . (($insn >> 16) & 31)/ge;           # t register
      $src =~ s/\bRD\b/'$r' . (($insn >> 11) & 31)/ge;           # d register

      $src =~ s/\$r0 = //g; # optimize away r0 assignments
      $src =~ s/\$r0\b/0/g; # optimise away r0 access

      my $cb = ($insn ? eval "sub { $src }" : $NOP)
         || die "$insn<$src>: $@";

#      $insn2src{$insn} = $src;
      $sub2insn{$cb+0} = $insn;

      $insn = $old_insn;#d#

      $cb
   }
}

sub cpu_reset($) {
   $pc = $_[0] >> 2;

   $r0  = 0;

          $r1  = $r2  = $r3  = $r4  = $r5  = $r6  = $r7  =
   $r8  = $r9  = $r10 = $r11 = $r12 = $r13 = $r14 = $r15 =
   $r16 = $r17 = $r18 = $r19 = $r20 = $r21 = $r22 = $r23 =
   $r24 = $r25 = $r26 = $r27 = $r28 =        $r30 =
   $hi  = $lo  = 0xdeadbeef;

   $r2  = 0;
   $r29 = STACK;
   $r31 = 0;

   $delay = $NOP; # start with a nop
}

sub cpu_run() {
   while () {
      $insn = $delay;

      if (PRIPS) {
         unless (++$::n & 0xfffff) {
            no integer;
            open my $tty, ">/dev/tty";
            printf {$tty} "%g ips\n", $::n / (Time::HiRes::time - $::t0);
            $::n = 0; $::t0 = Time::HiRes::time;#d#
         }
      }

      if (PRCPU) {
         defined $insn or die "undefined insn access\n";#d#
         cpu_pr;
      }

      $delay = vec($mem[$pc >> (ADDR_SHIFT - 2)], $pc & ADDR_MASK, 32);
      $delay = ($insn2sub{$delay} or get_insn($delay));
      ++$pc;

      &$insn;
   }
}

#############################################################################

sub mips_exec($$;$$) {
   my ($path, $argv, $envv, $auxv) = @_;

   mem_reset;

   my $file = $path;
   if (ref $path ne 'GLOB') {
     undef $file;
     die "open $path: $!" if !open($file, "<", $path);
   }

   my $elf_header;
   my $base_ofs = tell($file);
   die "seek: $!" if !seek($file, $base_ofs, 0);
   die "read: $!" if 0x32 != (read($file, $elf_header, 0x32) or 0);
   if ($elf_header =~ m@\A#!.*perl@s) {
     die "read: $!" if !defined(read($file, $elf_header, 131022, 0x32));
     my $i = index($elf_header, "\n_"."_"."DATA"."_"."_\n");
     if ($i > 0) {
       $elf_header = substr($elf_header, $i += 10, 0x32);
       $base_ofs += $i;
     }
   }

   # 32 bit, msb, elf version
   "\x7fELF\x01\x02\x01" eq substr $elf_header, 0, 7
      or die "not an elf file, or wrong class, encoding or version";

   my ($type, $machine, undef, $entry, $phoff, undef, undef,  undef, $phentsize, $phnum) = unpack "x16nnNNNNNnnn", $elf_header;

   $type == 2
      or die "file not an executable";

   $machine == 8
      or die "file not mips r3000 big endian";

   die "seek: $!" if !seek($file, $phoff + $base_ofs, 0);
   my $phents;
   die "read phents: $!" if 0x20 * $phnum !=
       (read($file, $phents, 0x20 * $phnum) or 0);
   for my $phi (0 .. $phnum - 1) {
      my ($type, $offset, $vaddr, $physaddr, $size, $memsz, $flags, $align) =
         unpack "N*", substr($phents, 0x20 * $phi, 0x20);

      $type != 2
         or die "dynamic loading is not supported";

      next unless $type == 1;
      next unless $size;

      die "seek: $!" if !seek($file, $offset + $base_ofs, 0);
      my $data;
      $size = ($size + 3) & ~3;
      while ($size > 0) {
         my $toread = $size < 65536 ? $size : 65536;
         # TODO(pts): Read smaller chunks.
         die "read: $!" if $toread != (read($file, $data, $toread) or 0);
         for my $o (0 .. ($toread >> 2) - 1) {
            my $w = vec($data, $o, 32);
            my $i = $vaddr + $o * 4;
            #printf "LOAD %08x = %08x\n", $i, $w;
            vec($mem[$i >> ADDR_SHIFT], ($i >> 2) & ADDR_MASK, 32) = $w;
         }
         $size -= $toread; $offset += $toread; $vaddr += $toread;
      }
   }

   cpu_reset $entry;

   {
      my $str = STACK + 65536;
      my $ptr = STACK;

      my $add_int = sub {
         memset $ptr, pack "N", $_[0];
         $ptr += 4;
      };

      my $add_str = sub {
         $add_int->($str);
         memset $str, "$_[0]\x00";
         $str += 1 + length $_[0];
      };

      $add_int->(scalar @$argv);
      $add_str->($_) for @$argv;
      $add_int->(0);

      $add_str->($_) for @$envv;
      $add_int->(0);

      # auxv
      $add_int->($_->[0]), $add_int->($_->[1])
         for @$auxv;

      $add_int->(0);
      $add_int->(0);
   }
}

if (0) {
   mips_exec
      "/tmp/dash-mipsel",
      ["./run", @ARGV],
#   ["sh", "-c", "for d in 0 1 2 3 4 5 6 7 8 9; do for a in 0 1 2 3 4 5 6 7 8 9; do for b in 0 1 2 3 4 5 6 7 8 9; do for c in 0 1 2 3 4 5 6 7 8 9; do :;done;done;done;done"],
      [map "$_=$ENV{$_}", keys %ENV];
} else {

   my $file;
   if (defined(fileno(DATA))) {
      die "binmode: $!" if !binmode(DATA);
      $file = \*DATA;
      unshift @ARGV, $0;
   } else {
      $file = $ARGV[0];
   }

   mips_exec $file, \@ARGV, [map "$_=$ENV{$_}", keys %ENV];
}

$::t0 = Time::HiRes::time;
$::n = 0;
cpu_run;
